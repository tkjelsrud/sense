<html>
<head>
  <meta charset="UTF-8" />
  <title>sense</title>
  <link rel="icon" type="image/x-icon" href="/img/favicon.ico" />

  <script src="https://cdn.jsdelivr.net/npm/tweakpane@3.1.1/dist/tweakpane.min.js"></script>
  <!--script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/nlp_compromise/3.0.0/nlp-compromise.es5.min.js"></script-->

  <style>
    body {
      font-family: monospace;
    }
    #search {
      background-color: lightskyblue;
      white-space: pre-line;
      margin-bottom: 20px;
      color: black;
    }

    #search:not(:focus) {
      color: grey;
    }

    #input {
      float:none;
      background-color: lightgrey;
      white-space: pre-line;
      margin-bottom: 20px;
      max-height: 300px;
      overflow: scroll;
    }
    #output {
      background-color: lightblue;
      white-space: pre-wrap;
      margin-bottom: 20px;
    }

    .termgroup {
      float: left;
    }

    .term {
      float: left;
      background-color: lightgoldenrodyellow;
      border-radius: 6px;
      margin-right: 4px;
      padding: 4px;
    }

    #promotedTerms .term {
      background-color: lightsalmon;
    }

    .button {
      background-color: grey;
      border-color: darkcyan;
      font-weight: bold;
      padding: 4px;
      min-height: 20px;
      width: 100px;
    }
  </style>

  <script src="lib/compromise.js"></script>
  <script src="lib/util.js"></script>
</head>

<body>

  <div id="viewSearch">
    <div id="search" contenteditable="true" onkeyup="search()">&nbsp;</div>
    <div id="btnSearch" class="button">Search</div>
  </div>
  <div id="viewEdit">
    <div id="input" contenteditable="true">&nbsp;</div>

    <div id="btnParse" class="button">Parse</div>

    <!--div id="output" contenteditable="false">&nbsp;</div-->

    <div id="foundTerms" class="termgroup">&nbsp;</div>
    <div id="promotedTerms" class="termgroup">&nbsp;</div>

    <div id="btnSave" class="button" onclick="saveClick()">Save</div>
  </div>

  <script type="text/javascript">
    //
    // Thinking this scope must be set pretty narrow
    // Its not going to be an all purpose search engine or chatbot or mastermind
    // It is simply going to be a note taking app with some required cataloging
    // In time the cataloging part should be automatic (learned)
    //
    // It will assist in recovering relevant notes or documents
    //
    // Node
    //   Some sort of ID (needed?)
    //   Its title or brief (when displayed)
    //   Its location in a hierarchy or map (dynamic)
    //   Date (when entered)
    //   Blob (trashable, the raw text, for reprocessing or keep as long as space is not an issue)
    //   People (list of known relations)
    //   Topics (list of keywords or phrases)
    //   
    // Pipeline
    //   Language prosessing steps, taking input "Dodcument" and giving output (more and more refined)
    //
    //
    // Relevant stuff to look into
    //   Fuzzy matching Compromise-fuzzy-matching
    //

    // https://cocopon.github.io/tweakpane/quick-tour/
    //
    //

    // NLP test

    function compareConfidence(a, b) {
      if ( a.confidence < b.confidence ){
        return -1;
      }
      if ( a.confidence > b.confidence ){
        return 1;
      }
      return 0;
    }

    document.getElementById("btnParse").addEventListener('click', 
      (event) => { 

        parseInput();
      }
    );

    //let terms = document.getElementsByClassName("term");
    //terms.forEach(t => { t.addEventListener('click', (event) => {
    //    console.log(event);
    //}); });

    document.getElementById("input").addEventListener('mouseup', 
      (event) => { 
        let d = nlp(getSelectedText());
        d.normalize();
        d.compute('root');
        d.toLowerCase();

        document.getElementById("foundTerms").innerHTML += termToDiv(d.json()[0].terms.map(t => t.root || t.normal).join(" "));
      }
    );

    function parseInput() {
      let d = nlp(document.getElementById("input").textContent.replaceAll('.', ' '));
        d = d.normalize().terms().nouns().toSingular().unique().toLowerCase();

        let tl = d.termList();
        
        tl.filter(t => { return (!t.dirty)});

        tl.sort(compareConfidence);

        let html = "";
        tl.forEach(t => {html += termToDiv(t.text)});
        
        document.getElementById("foundTerms").innerHTML = html;
    }

    function displayNode(node) {
      //domElement.innerHTML = trustedText.replace(/\r/g, '').replace(/\n/g, '<br>');
      document.getElementById("input").innerHTML = node.text.replace(/\n/g, '<br>');

      Object.keys(node.terms).forEach(t => {document.getElementById("promotedTerms").innerHTML += termToDiv(t, 'nextDrop')});

      parseInput();
    }

    function termToDiv(termText) {
      return `<div class="term" onClick="javascript:void(termClick('${termText}'))">${termText}</div>`;
    }

    function termClick(term) {
      //console.log(term);
      document.getElementById("promotedTerms").innerHTML += termToDiv(term);

    }

    function saveClick() {
      // Viewed text saved to node
      curNode.text = document.getElementById("input").innerText;

      Array.from(document.getElementById("promotedTerms").children).forEach(dt => {curNode.addTerm(dt.innerText, 0.5)});

      //
      //

      nList.save();

      PARAMS.log.push('saved');
    }

    function search() {
      let q = document.getElementById("search").innerText;
      
      console.log(q);

      // TODO: Add an index to lookup in and show list over relevant matches
    }

    // Allow me to select the most relevant terms or phrases
    // These can be stored/highlighted and weighted.
    // Ditch the rest of the text (to save space)
    // Important part is that we consider some kind of identity and its place in the index or hierarchy
    // However: that could be done later as long as we are able to find the node again
    //


    class NodeList {
      constructor() {
        this.list = new Array();
      }

      load() {
        let jsn = JSON.parse(localStorage.getItem("nodeList"));

        if(!jsn) return 0;

        for(let i = 0; i < jsn.length; i++) {
          this.list.push(new Node(jsn[i]));
        }

        return jsn.length;
      }

      save()Â {
        localStorage.setItem("nodeList", JSON.stringify(this.list.map(t => t.toJson())));
      }
    }

    class Node {
      constructor(jsn = null) {
        this.id = 0;
        this.type = 'node';
        this.text = "hello this is a node test";
        this.date = (new Date()).toLocaleString();
        this.url = "";
        this.terms = {};

        if(jsn)
          this.fromJson(jsn);
      }

      fromJson(jsn) {
        this.id = (jsn.id ? jsn.id : null);
        this.type = (jsn.type ? jsn.type : 'node');
        this.text = (jsn.text ? jsn.text : "");
        this.date = (jsn.date ? jsn.date : (new Date()).toLocaleString());
        this.url  = (jsn.url ? jsn.url : "");
        this.terms = (jsn.terms ? jsn.terms : {});
      }

      toJson() {
        return {'id': this.id, 'type': this.type, 'text': this.text, 'url': this.url, 'date': this.date, 'terms': this.terms};
      }

      addTerm(term, weight = 0) {
        this.terms[term] = weight;
      }
    }

    // Boot region
    //

    const nList = new NodeList();

    nList.load();

    // select node somehow (query param?)
    const curNode = nList.list[0];

    displayNode(curNode);

    const PARAMS = {
      nodes: nList.list.length,
      current: curNode.id,
      storeSize: calculateLocalStorageSize(),
      log: [],
    };

    const pane = new Tweakpane.Pane();

    pane.addInput(PARAMS, 'nodes', {step: 1});
    pane.addInput(PARAMS, 'current', {step: 1});
    pane.addInput(PARAMS, 'storeSize');


    document.getElementById("search").focus();

    /*pane.addMonitor(PARAMS, 'log', {
      multiline: true,
      lineCount: 5,
    });*/
  </script>
</body>
</html>
